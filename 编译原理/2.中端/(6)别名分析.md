别名分析（Alias Analysis）
=========================


指针分析对于可以任意访问指针和进行指针计算的语言（如C/C++等）具有重要意义。指针分析通过静态计算一个指针可能指向的对象，可以推断出非常多有用的信息。当然由于缺乏运行时信息，推断一般是*保守的*（即，结论是可能发生，而不是必然发生）。

对于指针分析，有两个重要的问题：

1. 指针的别名问题：即指针p和q是否可能指向同一个对象。
2. 指针的指向问题：即指针p可能指向哪些对象。

本节中我们就将主要讨论别名分析（Alias Analysis）。
别名分析的关键在于如何表示指针的别名关系。一般来说，有两种方式：

1. **指针集合**（Pointer Sets）：将每个指针表示为一个集合，集合中包含了指针可能指向的所有对象。这种方式的优点是简单直观，但是对于指针的别名关系的表示不够精确。
2. **别名图**（Alias Graph）：将每个指针表示为一个节点，如果两个指针可能指向同一个对象，则在它们之间连一条边。这种方式的优点是可以精确地表示别名关系，但是图的构建和分析比较复杂。


## 别名分析的应用

别名分析在编译器优化中有着重要的应用，例如：

1. 冗余代码消除（Dead Code Elimination）：如果一个指针p在某个位置被赋值为NULL，那么在这之后所有通过p访问的对象都是无效的，可以被消除。
2. 冗余加载消除（Load Elimination）：如果一个指针p在某个位置被赋值为q，那么在这之后所有通过p访问的对象都可以被替换为q。
3. 冗余存储消除（Store Elimination）：如果一个指针p在某个位置被赋值为q，那么在这之后所有通过p访问的对象的存储可以被替换为q。
4. 循环不变代码外提（Loop Invariant Code Motion）：如果一个指针p在循环内部没有被修改，那么可以将p的加载提到循环外部。

这些优化都需要依靠准确的别名分析结果。

## 指针和内存的表示方法

在别名分析中，我们需要对指针和内存进行抽象表示。一般来说，有这样几种方式：

1. **内存对象**（Memory Object）：将内存抽象为一个对象，对象包含了内存的地址和大小。这种方式的优点是简单直观，但是对于内存的精确表示不够。
2. **内存区域**（Memory Region）：将内存抽象为一个区域，区域包含了内存的地址、大小和类型等信息。这种方式的优点是可以精确地表示内存的属性，但是对于内存的抽象和分析比较复杂。
3. **内存单元**（Memory Unit）：将内存抽象为一个单元，单元包含了内存的地址、大小和类型等信息。这种方式的优点是可以精确地表示内存的属性，但是对于内存的抽象和分析比较复杂。

分配和释放内存也是我们需要考虑的关键事件。






## 基于指针集合的别名分析

指针集合是一种简单直观的别名分析表示方式。在这种方式中，每个指针都表示为一个集合，集合中包含了指针可能指向的所有对象。
为了简单起见，我们先考虑单个函数内，只有局部变量的情况。例如，对于下面的代码：

```c
int *p, *q;
int a, b;
p = &a;
q = &b;
```

我们可以得到如下的指针集合：

```
p -> {a}
q -> {b}
```











